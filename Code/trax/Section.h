//	trax track library
//	AD 2013 
//
//  "the resolution of all the fruitless searches"
//
//								Peter Gabriel
//
// Copyright (c) 2025 Trend Redaktions- und Verlagsgesellschaft mbH
// Copyright (c) 2019 Marc-Michael Horstmann
//
// Permission is hereby granted to any person obtaining a copy of this software 
// and associated source code (the "Software"), to use, view, and study the 
// Software for personal or internal business purposes, subject to the following 
// conditions:
//
// 1. Redistribution, modification, sublicensing, or commercial use of the 
// Software is NOT permitted without prior written consent from the copyright 
// holder.
//
// 2. The Software is provided "AS IS", without warranty of any kind, express 
// or implied.
//
// 3. All copies of the Software must retain this license notice.
//
// For additional permissions, please contact: horstmann.marc@trendverlag.de

#pragma once

#include "Configuration.h"
#include "Units.h"

#include "common/Interval.h"
#include "spat/Rect.h"
#include "spat/Position2D.h"
#include "spat/Vector2D.h"

#include "Units.h"

namespace trax{

	/// \brief A profile of a track.
	///
	/// Section specifies a vertical section through a track to define its 
	/// profile. Special sections are available for commonly used track profiles.
	struct Section{

		/// \brief Name for the object type that implements this interface. 
		virtual std::string	TypeName() const = 0;


		/// \brief Predefined cross sections.
		enum class SpecialSections{
			unknown = -1,
			empty = 0,					///< section with no points in it.
			custom,						///< section with no name but generated by custom code
			standard,					///< simple section
			vignol_UIC60,				///< vignol UIC60
			eepv7_grooved_convextread,	///< section with grooved rods and convex shaped top
			eep_embankment_simple,		///< very simple track and high embankment
			eep_concrete_roadway,		///< rods fixed in concrete
			eep_rack_railway,			///< simple track with cogs in the center
			eep7_track1435,				///< high embankment narrow rod plus convex shaped top
			eep_simple,					///< very simple epp track
			eep_grooved_convextread,	///< section with grooved rods and convex shaped top
			eep_flatballast,			///< flat ballast without rods
			eepv7_track1000,			///< high embankment narrow track narrow rod plus convex shaped top
			eep_simple2,				///< very simple epp track. high embankment.
			eep_simple3,				///< very simple epp track. high embankment.
			eep_flatballast_rods,		///< flat ballast with rods
			square,						///< four points profile
			hexagon,					///< six points profile
			pipeline,					///< round profile.
		};

		/// \brief Makes a Section object.
		static dclspc std::unique_ptr<Section> Make( SpecialSections special = SpecialSections::empty ) noexcept;

		virtual SpecialSections GetSectionType() const noexcept = 0;


		/// \brief Point structure used to describe a section.
		struct SectionPoint{
			spat::Position2D<Length>	p;	///< Position of profile point
			spat::Vector2D<One>			n;	///< Normal of profile point
			One							t;	///< Texture length along the profile. Used for texture coordinates.


			/// \name Construction
			///@{
			SectionPoint() noexcept
			:	p{},
				n{},
				t{}
			{}

			SectionPoint( const spat::Position2D<Length>& pt ) noexcept
			:	p{pt},
				n{0,1},
				t{0}
			{}

			SectionPoint( const spat::Position2D<Length>& pt, const spat::Vector2D<One>& d, One tex ) noexcept
			:	p{pt},
				n{d},
				t{tex}
			{}
			///@}


			/// \name Scaling
			/// \param scale scaling value to scale both axes.
			/// \param x_scale scaling value to scale x axis.
			/// \param y_scale scaling value to scale y axis.
			///@{
			SectionPoint& Scale( One scale ) noexcept{
				return Scale( scale, scale );
			}

			SectionPoint& Scale( One x_scale, One y_scale ) noexcept{
				p.x *= x_scale;
				p.y *= y_scale;
				n.dx /= x_scale;
				n.dy /= y_scale;
				n.Normalize();
				return *this;
			}
			///@}

		};


		/// \brief Creates a special section, creates the section points
		/// if applicable.
		virtual void Create( SpecialSections specialSection ) = 0;


		/// \returns Total number of profile points.
		virtual int CountPoints() const = 0;


		/// \brief Sets the total number of profile points.
		virtual void SetCntPoints( int cnt ) = 0;


		/// \param id zero based index of SectionPoint.
		/// \returns the section point with index id.
		virtual const SectionPoint&	Get( int id ) const = 0;


		/// \brief Gives the maximum difference between 
		/// the t values of any two SectionPoints. 
		/// \returns the width of the texture value along the segment.
		virtual common::Interval<One> TextureExtent() const = 0;


		/// \returns The total length of the profile along the segment points.
		virtual Length PolygonChainLength() const noexcept = 0;


		/// \returns The gauge the segment represents.
		virtual Length Gauge() const noexcept = 0;


		/// \returns A axis aligned rect that contains all the points of the section.
		virtual spat::Rect<Length> Clearance() const noexcept = 0;


		/// \brief Sets the section point with index id.
		/// \param id zero based index of SectionPoint.
		/// \param pt Value to set the point to.
		/// \param bGaugeLeft This point represents the inner face of the load-bairing rail on the left.
		/// \param bGaugeRight This point represents the inner face of the load-bairing rail on the right.
		virtual void Set( int id, const SectionPoint& pt, bool bGaugeLeft = false, bool bGaugeRight = false ) = 0;


		/// \brief Scales all the points and normals by factors. 
		virtual void Scale( One x_scale, One y_scale ) = 0;


		/// \brief Calculates the normals from positions of the points automatically.
		virtual void CalculateNormals() noexcept = 0;

		/// \brief Calculates the texture coordinate t from positions of the points automatically.
		virtual void CalculateTextureCoordinates() = 0;


		virtual ~Section() = default;
		Section( const Section& ) = delete;
		Section( Section&& ) = delete;
		Section& operator=( const Section& ) = delete;
		Section& operator=( Section&& ) = delete;
	protected:
		Section() = default;
	};

	dclspc std::string ToString( Section::SpecialSections specialSection );

	dclspc Section::SpecialSections SpecialSection( const std::string& string );
}